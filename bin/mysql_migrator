#!/usr/bin/env ruby

# This is a quick one-off script to migrate stuff from Coyote's original MySQL DB into today's Postgres DB

require ::File.expand_path('../../config/environment', __FILE__)
require 'mysql2'

class User
  protected

  def password_required?
    return false
  end
end

uri = URI.parse(ENV.fetch('JAWSDB_URL'))
db = uri.path[1..-1]
client = Mysql2::Client.new(host: uri.host, username: uri.user, database: db, password: uri.password)

org = Organization.find(1)

meta = client.query('SELECT * FROM meta').to_a
org.meta.create!(meta.to_a)
puts "Metum: #{Metum.count}"

resource_groups = client.query(<<~SQL
SELECT DISTINCT i.group_id AS id, g.title
FROM images i
INNER JOIN groups g
ON i.group_id = g.id
SQL
).to_a

org.resource_groups.create!(resource_groups.to_a)
puts "resource_group: #{ResourceGroup.count}"

users = client.query('SELECT * FROM users').to_a

users.each do |u|
  role = if u.delete('admin') == 1
           :admin
         else
           :editor
         end

  user = User.create!(u)
  Membership.create!(user: user, organization: org, role: role)
end

puts "user: #{User.count}"

images = client.query('SELECT * FROM images')

resources = images.to_a.map do |image|
  image.delete('priority')

  path = image.delete('path')
  image['source_uri'] = "https://mcachicago.org#{path}"

  image.delete('website_id')
  image['resource_group_id'] = image.delete('group_id')

  image.delete('assignments_count')
  image.delete('descriptions_count')
  image.delete('status_code')
  image['host_uris'] = JSON.parse(image.delete('page_urls')).join("\n")
  image['resource_type'] = 'still_image'
  image['identifier'] = image['id']

  image.delete('title') if image['title'].blank? # use DB default in this case
  image
end

org.resources.create!(resources)
puts "resource: #{Resource.count}"

statuses = {}
client.query('SELECT * from statuses').each do |status|
  statuses[status["id"]] = status["title"].downcase.gsub(" ", "_")
end

license = License.find_by!(name: 'cc0-1.0')

descriptions = client.query('SELECT * from descriptions')

endpoint = Endpoint.first

representations = descriptions.to_a.map do |rep|
  rep['language'] = rep.delete('locale')
  status = rep.delete('status_id')
  status = statuses.fetch(status)
  rep['status'] = status
  rep['resource_id'] = rep.delete('image_id')
  rep['author_id'] = rep.delete('user_id')
  rep.delete('license')
  rep['endpoint_id'] = endpoint.id
  rep['license_id'] = license.id
  rep
end

Representation.create!(representations)
puts "representation: #{Representation.count}"

audits = client.query("SELECT * from audits").to_a

audits.each do |a|
  a['username'] = a['username'].presence || 'Unknown'
  a['auditable_type'] = 'Representation' if a['auditable_type'] == 'Description'
  a['audited_changes'] = YAML.parse(a['audited_changes']).to_ruby if a['audited_changes'] =~ /^---/
end

Audits = Class.new(ActiveRecord::Base)
Audits.connection.execute %{TRUNCATE TABLE audits}
Audits.create!(audits)

# Reset Postgres sequences per https://stackoverflow.com/a/38575949/308448
ActiveRecord::Base.connection.execute %{SELECT 'SELECT SETVAL(' ||
       quote_literal(quote_ident(PGT.schemaname) || '.' || quote_ident(S.relname)) ||
       ', COALESCE(MAX(' ||quote_ident(C.attname)|| '), 1) ) FROM ' ||
       quote_ident(PGT.schemaname)|| '.'||quote_ident(T.relname)|| ';'
FROM pg_class AS S,
     pg_depend AS D,
     pg_class AS T,
     pg_attribute AS C,
     pg_tables AS PGT
WHERE S.relkind = 'S'
    AND S.oid = D.objid
    AND D.refobjid = T.oid
    AND D.refobjid = C.attrelid
    AND D.refobjsubid = C.attnum
    AND T.relname = PGT.tablename
ORDER BY S.relname;
}

puts "ALL DONE"
